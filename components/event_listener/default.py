# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import asyncio
import sys
from pathlib import Path

from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import context, events
from langbot_plugin.api.entities.builtin.platform.message import MessageChain, Plain


class DefaultEventListener(EventListener):
    async def initialize(self):
        await super().initialize()

        from pkg.config import get_config
        from pkg.split import SplitText
        from pkg.state import get_state, uid

        self.split_engine = SplitText()

        def split_text(text: str) -> list:
            config = get_config()
            if config.split_mode == "simple":
                return self.split_engine.simple_split(text)
            return self.split_engine.split(text)

        @self.handler(events.PersonNormalMessageReceived)
        async def person_normal_message_received(ctx: context.EventContext):
            sender_id = ctx.event.sender_id  # type: ignore
            get_state().enable(uid(ctx.event.launcher_type, sender_id))  # type: ignore

        @self.handler(events.GroupNormalMessageReceived)
        async def group_message_received(ctx: context.EventContext):
            launcher_type = group_id = ctx.event.launcher_type  # type: ignore
            group_id = ctx.event.launcher_id  # type: ignore
            get_state().enable(uid(launcher_type, group_id))

        @self.handler(events.NormalMessageResponded)
        async def normal_message_responded(ctx: context.EventContext):
            chat_type = ctx.event.launcher_type  # type: ignore
            chat_id = (
                ctx.event.launcher_id if chat_type == "group" else ctx.event.sender_id  # type: ignore
            )  # type: ignore
            state = get_state()
            config = get_config()

            if not state.is_enabled(uid(chat_type, chat_id)):
                return

            response_text = ctx.event.response_text  # type: ignore
            lock = state.get_lock(uid(chat_type, chat_id))

            async with lock:
                if len(response_text) > config.max_segment_length:
                    return

                parts = split_text(response_text)
                if parts:
                    ctx.prevent_default()
                    for i, part in enumerate(parts, 1):
                        typing_delay = min(
                            len(part) * config.char_delay,
                            config.segment_delay_max,
                        )
                        await ctx.reply(MessageChain([Plain(text=part)]))
                        await asyncio.sleep(typing_delay)
                        if i < len(parts):
                            await asyncio.sleep(config.segment_pause)
