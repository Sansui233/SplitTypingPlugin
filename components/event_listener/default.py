# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import asyncio

from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import context, events
from langbot_plugin.api.entities.builtin.platform.message import MessageChain, Plain

from lib.config import get_config
from lib.split import SplitText
from lib.state import get_state


class DefaultEventListener(EventListener):
    async def initialize(self):
        await super().initialize()

        self.split_engine = SplitText()

        @self.handler(events.PersonNormalMessageReceived)
        async def person_normal_message_received(ctx: context.EventContext):
            sender_id = ctx.event.sender_id  # type: ignore
            get_state().enable(sender_id)

        @self.handler(events.GroupNormalMessageReceived)
        async def group_message_received(ctx: context.EventContext):
            group_id = ctx.event.launcher_id  # type: ignore
            get_state().enable(group_id)

        @self.handler(events.NormalMessageResponded)
        async def normal_message_responded(ctx: context.EventContext):
            chat_type = ctx.event.launcher_type  # type: ignore
            chat_id = (
                ctx.event.launcher_id if chat_type == "group" else ctx.event.sender_id  # type: ignore
            )  # type: ignore
            state = get_state()
            config = get_config()

            if not state.is_enabled(chat_id):
                return

            response_text = ctx.event.response_text  # type: ignore
            lock = state.get_lock(chat_type, chat_id)

            async with lock:
                if len(response_text) > config.max_segment_length:
                    return

                parts = self.split_text(response_text)
                if parts:
                    ctx.prevent_default()
                    for i, part in enumerate(parts, 1):
                        typing_delay = min(
                            len(part) * config.char_delay,
                            config.segment_delay_max,
                        )
                        await ctx.reply(MessageChain([Plain(text=part)]))
                        await asyncio.sleep(typing_delay)
                        if i < len(parts):
                            await asyncio.sleep(config.segment_pause)

    def split_text(self, text: str) -> list:
        config = get_config()
        if config.split_mode == "simple":
            return self.split_engine.simple_split(text)
        return self.split_engine.split(text)
